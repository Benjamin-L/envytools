<?xml version="1.0" encoding="UTF-8"?>
<database xmlns="http://nouveau.freedesktop.org/"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://nouveau.freedesktop.org/ rules-ng.xsd">
<import file="copyright.xml"/>

<import file="nvchipsets.xml" />
<import file="nv50_defs.xml" />

<domain name="NV_MMIO" bare="yes" prefix="chipset">
<array name="PGRAPH" offset="0x400000" stride="0x10000" length="1" variants="NV50:NVC0">
	<reg32 offset="0x0040" name="DISABLE">
		<brief>Disable / reset subunits</brief>
		<doc>Writing 1 to a bit disables given subunit, causes it to disappear from MMIO,
		and [at least sometimes] resets its state.
		
		ctxprog opcode 90XXXX ors low 16 bits of this register with XXXX, 91XXXX ors high
		16 bits of this register with XXXX. CMD 9 resets this register to 0.

		Trying to launch a ctxprog xfer touching a disabled subunit is a bad idea.
		</doc>
		<bitfield pos="0" name="DISPATCH"/>
		<bitfield pos="1" name="M2MF"/>
		<bitfield pos="2" name="VFETCH"/>
		<bitfield pos="3" name="CCACHE"/>
		<bitfield pos="4" name="PREGEOM"/>
		<bitfield pos="5" name="POSTGEOM"/>
		<bitfield pos="6" name="VATTR"/>
		<bitfield pos="7" name="STRMOUT"/>
		<bitfield pos="8" name="VCLIP"/>
		<bitfield pos="9" name="TPC_RAST"/>
		<bitfield pos="10" name="TPC_PROP"/>
		<bitfield pos="11" name="TPC_TEX"/>
		<bitfield pos="12" name="TPC_GEOM"/>
		<bitfield pos="13" name="TPC_MP"/>
		<bitfield pos="14" name="RATTR"/>
		<bitfield pos="15" name="APLANE"/>
		<bitfield pos="16" name="TRAST"/>
		<bitfield pos="17" name="CLIPID"/>
		<bitfield pos="18" name="ZCULL"/>
		<bitfield pos="19" name="ENG2D"/>
		<bitfield pos="20" name="RMASK"/>
		<bitfield pos="21" name="ROP"/>
		<bitfield pos="22" name="TPC_CTRL"/>
	</reg32>
	<reg32 offset="0x0060" name="UNK60" />
	<reg32 offset="0x0080" name="DEBUG_0">
		<bitfield pos="4" name="INVALID_OBJECT_CHECK"/>
		<bitfield pos="6" name="INVALID_STATE_CHECK"/>
		<bitfield pos="7" name="INVALID_COMMAND_CHECK"/> <!-- also INVALID_ENUM, INVALID_OPERATION, ILLEGAL_MTHD, ILLEGAL_CLASS, BEGIN_END_ACTIVE -->
		<bitfield pos="8" name="INVALID_BITFIELD_CHECK"/>
		<bitfield pos="9" name="UNK9"/> <!-- makes COMPUTE not work for some reason. -->
	</reg32>
	<reg32 offset="0x0084" name="UNK84">
		<doc>This register is write-only. The blob writes 0x20 after
		reading PM performance counters. Checked on nv86, nv96 and nva3.</doc>
	</reg32>
	<reg32 offset="0x0088" name="DEBUG_2"/>
	<reg32 offset="0x008c" name="DEBUG_3">
		<bitfield pos="2" name="HW_CONTEXT_SWITCH"/>
		<bitfield pos="8" name="SINGLE_STEP"/>
	</reg32>
	<reg32 offset="0x0100" name="INTR">
		<brief>Interrupt status</brief>
		<doc>Shows currently pending interrupts. Write 1 to a bit to reset it, and ACK the interrupt.</doc>
		<bitfield pos="0" name="NOTIFY">
			<doc>You asked for a NOTIFY with interrupt and got it.</doc>
		</bitfield>
		<bitfield pos="1" name="QUERY">
			<doc>You asked for a QUERY with interrupt and got it.</doc>
		</bitfield>
		<bitfield pos="2" name="SYNC">
			<doc>You sent a sync QUERY command and it triggered.</doc>
		</bitfield>
		<bitfield pos="4" name="ILLEGAL_MTHD">
			<doc>You tried to use a method that doesn't exist on this class.</doc>
		</bitfield>
		<bitfield pos="5" name="ILLEGAL_CLASS">
			<doc>You tried to use a class not supported by this GPU.</doc>
		</bitfield>
		<bitfield pos="6" name="DOUBLE_NOTIFY">
			<doc>You tried to use NOTIFY command on another NOTIFY command.</doc>
		</bitfield>
		<bitfield pos="12" name="CONTEXT_SWITCH">
			<doc>PGRAPH needs a context switch, and automatic context switches are disabled.</doc>
		</bitfield>
		<bitfield pos="16" name="BUFFER_NOTIFY">
			<doc>You asked for m2mf transfer with interrupt after finish and got it.</doc>
		</bitfield>
		<bitfield pos="20" name="DATA_ERROR">
			<doc>You used an invalid parameter for this method. Or maybe you tried
			to launch some operation, but the relevant state is inconsistent.
			Relevant state is in DATA_ERROR</doc>
		</bitfield>
		<bitfield pos="21" name="TRAP">
			<doc>A PGRAPH command failed in the middle of execution. TRAP register will
			tell you which subunit reports the trap.</doc>
		</bitfield>
		<bitfield pos="22" name="UNK22"/>
		<bitfield pos="24" name="SINGLE_STEP"/>
		<bitfield pos="25" name="CTXPROG_SINGLE_STEP"/>
	</reg32>
	<reg32 offset="0x0108" name="TRAP">
		<brief>Trap status</brief>
		<doc>Like INTR, but applies to TRAP sub-types. Shows which subunits report trap.
		Each subunit has its own TRAP status register, which you have to check in turn
		to know the exact TRAP sub-subtype, and reset it. Write 1 to a bit to reset it
		and ACK the trap.
		
		If a bit applies to a per-TPC subunit, you need to check all TPCs to see which one
		is reporting the trap.</doc>
		<bitfield pos="0" name="DISPATCH">
			<brief>Check 400804</brief>
		</bitfield>
		<bitfield pos="1" name="M2MF">
			<brief>Check 406800</brief>
		</bitfield>
		<bitfield pos="2" name="VFETCH">
			<brief>Check 400c04</brief>
		</bitfield>
		<bitfield pos="3" name="STRMOUT">
			<brief>Check 401800</brief>
		</bitfield>
		<bitfield pos="4" name="CCACHE">
			<brief>Check 405018</brief>
		</bitfield>
		<bitfield pos="5" name="CLIPID">
			<brief>Check 402000</brief>
		</bitfield>
		<bitfield pos="6" name="TEX">
			<brief>Check TPC+0x900 / TPC+0x600</brief>
		</bitfield>
		<bitfield pos="7" name="MP">
			<brief>Check TPC+0x314 / TPC+0x31c</brief>
		</bitfield>
		<bitfield pos="8" name="PROP">
			<brief>Check TPC+0xe08 / TPC+0x708</brief>
		</bitfield>
	</reg32>
	<reg32 offset="0x0110" name="DATA_ERROR" type="NV50_PGRAPH_DATA_ERROR">
		<doc>Stores type of the pending DATA_ERROR.</doc>
	</reg32>
	<reg32 offset="0x0138" name="TRAP_EN">
		<brief>Trap enable</brief>
		<doc>A bitmask of events that will cause traps, same bit assignments as in TRAP reg.</doc>
		<bitfield pos="0" name="DISPATCH"/>
		<bitfield pos="1" name="M2MF"/>
		<bitfield pos="2" name="VFETCH"/>
		<bitfield pos="3" name="STRMOUT"/>
		<bitfield pos="4" name="CCACHE"/>
		<bitfield pos="5" name="CLIPID"/>
		<bitfield pos="6" name="TEX"/>
		<bitfield pos="7" name="MP"/>
		<bitfield pos="8" name="PROP"/>
	</reg32>
	<reg32 offset="0x013c" name="INTR_EN">
		<brief>Interrupt enable</brief>
		<doc>A bitmask of events that will cause interrupts, same bit assignments as in INTR reg.</doc>
		<bitfield pos="0" / name="NOTIFY">
		<bitfield pos="1" / name="QUERY">
		<bitfield pos="2" / name="SYNC">
		<bitfield pos="4" / name="ILLEGAL_MTHD">
		<bitfield pos="5" / name="ILLEGAL_CLASS">
		<bitfield pos="6" / name="DOUBLE_NOTIFY">
		<bitfield pos="12" / name="CONTEXT_SWITCH">
		<bitfield pos="16" / name="BUFFER_NOTIFY">
		<bitfield pos="20" / name="DATA_ERROR">
		<bitfield pos="21" / name="TRAP">
		<bitfield pos="22" / name="UNK22">
		<bitfield pos="24" / name="SINGLE_STEP">
		<bitfield pos="25" / name="CTXCTL_SINGLE_STEP">
	</reg32>

	<reg32 offset="0x0200" name="ICMD_CMD" />
	<reg32 offset="0x0204" name="ICMD_DATA" />

	<reg32 offset="0x0300" name="CTXCTL_STATUS">
		<brief>ctxprog status</brief>
		<!-- TODO: Figure this out.-->
		<bitfield pos="0" name="RUNNING"/>
		<bitfield pos="1" name="DISPATCH_FREE"/>
		<!-- bits 2 and 3 light up when PC == 0... wtf? -->
		<bitfield low="4" high="5" name="STATE">
			<value value="0" name="IDLE"/>
			<value value="1" name="FETCH"/>
			<value value="2" name="EXECUTE"/>
			<value value="3" name="SINGLE_STEP_WAIT"/>
		</bitfield>
		<bitfield pos="8" name="NEXTDIFFERS"/> <!-- CUR != NEXT -->
		<bitfield low="12" high="31" name="TIMER"/>
	</reg32>
	<reg32 offset="0x0304" name="CTXCTL_CONTROL">
		<bitfield pos="0" name="RUN"/>
		<bitfield pos="1" name="RESET_EXECUTE"/>
		<bitfield pos="2" name="RESET_PC"/>
		<bitfield pos="3" name="RESET_FLAGS"/>
		<bitfield pos="4" name="SINGLE_STEP_ENABLE"/>
	</reg32>
	<reg32 offset="0x0308" name="CTXCTL_OPCODE">
 		<doc>Next opcode to execute, or the exit opcode if program exitted.</doc>
	</reg32>
	<reg32 offset="0x030c" name="CTXCTL_PC_RD" access="r">
 		<doc>RO alias of PC for some reason</doc>
	</reg32>
	<reg32 offset="0x0310" name="CTXCTL_PC">
 		<doc>Program Counter. Readable and writable. In units of single insns.</doc>
	</reg32>
	<reg32 offset="0x031c" name="CTXCTL_SCRATCH">
 		<doc>ctxprog scratch register, holding params to various opcodes/CMDs. Written by opcode 2XXXXX.</doc>
	</reg32>
	<reg32 offset="0x0320" name="CTXCTL_CMD" access="w">
		<doc>CMD register. Writing here launches a given CMD.</doc>
		<value value="0x4" name="NEWCTXDMA" />
		<value value="0x5" name="NEXT_TO_SWAP" />
		<value value="0x6" name="SET_REG_POINTER" />
		<value value="0x7" name="SET_XFER_POINTER" />
		<value value="0x8" name="TIMER_START" />
		<value value="0x9" name="ENABLE" />
		<value value="0xa" name="UNK0A" />
		<value value="0xb" name="UNK0B" />
		<value value="0xc" name="END" />
		<value value="0xd" name="NEXT_TO_CURRENT" />
		<value value="0xe" name="SINGLE_STEP" />
		<value value="0xf" name="UNK0F" /> <!-- causes 101 in STATUS, 200 in FLAGS_2 -->
		<value value="0x11" name="UNK11" />
		<value value="0x12" name="UNK12" /> <!-- causes some new registers to appear / light up. fun. -->
		<value value="0x16" name="UNK16" />
	</reg32>
	<reg32 offset="0x0324" name="CTXCTL_INDEX" access="w">
		<doc>Code upload index. Selects address to write in ctxprog code, counted in insns.</doc>
	</reg32>
	<reg32 offset="0x0328" name="CTXCTL_DATA" access="w">
		<doc>Code upload. Writes given insn to code storage and autoincrements upload index.</doc>
	</reg32>
	<reg32 offset="0x032c" name="CTXCTL_CUR">
		<doc>Current channel.</doc>
		<bitfield name="CHAN" high="29" low="0" type="nv50_channel"/>
		<bitfield name="VALID" pos="31"/>
	</reg32>
	<reg32 offset="0x0330" name="CTXCTL_NEXT">
		<doc>Next channel: the one that PFIFO wants us to switch to.</doc>
		<bitfield name="CHAN" high="29" low="0" type="nv50_channel"/>
		<bitfield name="VALID" pos="31"/>
	</reg32>
	<reg32 offset="0x0334" name="CTXCTL_PTR_REG">
		<doc>Offset in grctx to read/write with opcode 1XXXXX. In units of 32-bit words.</doc>
	</reg32>
	<reg32 offset="0x0338" name="CTXCTL_SCRATCH2">
		<doc>Some register, set with opcode 3XXXXX. No known use on NV50, on NVA0 selects
		which TPC to read/write via 1XXXXX opcode. Maybe generic MMIO offset? Or really offsets
		all TPCs even on non-ctxprog accesses?</doc> <!-- TODO -->
	</reg32>
	<reg32 offset="0x033c" name="CTXCTL_PTR_XFER">
		<doc>Offset in grctx to read/write with opcode 8XXXXX. In units of 32-bit words.</doc>
	</reg32>

	<reg32 offset="0x0380" name="VSTATUS_0">
		<bitfield low="0" high="2" name="VFETCH" type="NV50_VSTATUS"/>
		<bitfield low="3" high="5" name="CCACHE" type="NV50_VSTATUS"/>
		<bitfield low="6" high="8" name="PREGEOM" type="NV50_VSTATUS"/>
		<bitfield low="9" high="11" name="POSTGEOM" type="NV50_VSTATUS"/>
		<bitfield low="12" high="14" name="VATTR" type="NV50_VSTATUS"/>
		<bitfield low="15" high="17" name="STRMOUT" type="NV50_VSTATUS"/> <!-- untested -->
		<bitfield low="18" high="20" name="VCLIP" type="NV50_VSTATUS"/>
	</reg32>
	<reg32 offset="0x0384" name="VSTATUS_1">
		<bitfield low="0" high="2" name="TPC_RAST" type="NV50_VSTATUS"/>
		<bitfield low="3" high="5" name="TPC_PROP" type="NV50_VSTATUS"/>
		<bitfield low="6" high="8" name="TPC_TEX" type="NV50_VSTATUS"/> <!-- untested -->
		<bitfield low="9" high="11" name="TPC_GEOM" type="NV50_VSTATUS"/> <!-- untested -->
		<bitfield low="12" high="14" name="TPC_MP" type="NV50_VSTATUS"/>
	</reg32>
	<reg32 offset="0x0388" name="VSTATUS_2">
		<bitfield low="0" high="2" name="RATTR" type="NV50_VSTATUS"/>
		<bitfield low="3" high="5" name="APLANE" type="NV50_VSTATUS"/>
		<bitfield low="6" high="8" name="TRAST" type="NV50_VSTATUS"/>
		<bitfield low="9" high="11" name="CLIPID" type="NV50_VSTATUS"/>
		<bitfield low="12" high="14" name="ZCULL" type="NV50_VSTATUS"/>
		<bitfield low="15" high="17" name="ENG2D" type="NV50_VSTATUS"/>
		<bitfield low="18" high="20" name="RMASK" type="NV50_VSTATUS"/>
		<bitfield low="21" high="23" name="ROP" type="NV50_VSTATUS"/>
	</reg32>

	<stripe offset="0x0400" name="STRAND">
		<reg32 offset="0x00" name="BUSY" access="r"/>
		<reg32 offset="0x04" name="CTRL">
			<bitfield low="0" high="4" name="CNT"/>
			<bitfield low="8" high="10" name="STRAND_IDX"/>
			<bitfield pos="12" name="AREA_SELECT"/>
			<bitfield pos="14" name="UNK14"/>
			<bitfield pos="15" name="UNK15"/>
			<bitfield pos="16" name="DIR">
				<value value="0" name="READ"/>
				<value value="1" name="WRITE"/>
			</bitfield>
			<bitfield pos="17" name="TRIGGER"/>
		</reg32>
		<reg32 offset="0x08" name="ADDR">
			<bitfield low="0" high="11" name="SUBIDX"/>
			<bitfield low="12" high="15" name="UNK12"/>
			<bitfield low="16" high="29" name="SEEKPOINT"/>
		</reg32>
		<reg32 offset="0x20" name="DATA" length="20"/>
	</stripe>
	
	<stripe offset="0x0500" name="FIFO">
		<brief>pre-DISPATCH FIFO control</brief>
		<doc>This pair of registers deals with PGRAPH's method FIFO.
		PFIFO pushes methods here, DISPATCH pulls them out and
		executes. The FIFO itself is buried inside DISPATCH's context
		strand, and contains 8 [NV50] or 0x100 [NV84+] repetitions of
		method + subchannel + inc/noninc + single/double + data1
		+ data2 + 1 unknown bit. DISPATCH_CMD will pull the last
		method from the FIFO whenever it's free and FIFO contains
		stuff.
		</doc>
		<reg32 offset="0x00" name="CONTROL">
			<bitfield pos="0" name="PULL">
				<doc>Enables executing commands incoming through DISPATCH_CMD.</doc>
			</bitfield>
			<bitfield pos="8" name="UNK8"/>
			<bitfield pos="16" name="UNK16"/> <!-- usually set, but doesn't seem needed for operation... -->
			<bitfield high="28" low="20" name="LIMIT" variants="NV84-">
				<doc>Max number of slots allowed to be occupied in FIFO. 0 and > 0x100 are treated as 0x100.</doc>
			</bitfield>
		</reg32>
		<reg32 offset="0x04" name="STATUS" access="r">
			<bitfield pos="0" name="EMPTY" />
			<bitfield pos="1" name="FULL" />
			<bitfield high="7" low="4" name="OCCUPIED" variants="NV50">
				<doc>How many slots contain valid data atm.</doc>
			</bitfield>
			<bitfield high="11" low="8" name="GET" variants="NV50" />
			<bitfield high="19" low="16" name="PUT" variants="NV50" />
			<bitfield high="15" low="4" name="OCCUPIED" variants="NV84-">
				<doc>How many slots contain valid data atm.</doc>
			</bitfield>
			<bitfield high="23" low="16" name="GET" variants="NV84-" />
			<bitfield high="31" low="24" name="PUT" variants="NV84-" />
		</reg32>
	</stripe>

	<reg32 offset="0x0700" name="STATUS" access="r">
		<doc>Shows which parts of PGRAPH are currently busy with doing some stuff. 1 means busy, 0 means idle.</doc>
		<!-- missing: UNK24XX -->
		<bitfield pos="0" name="ALL">
			<doc>Is 1 if anything at all is busy.</doc>
		</bitfield>
		<bitfield pos="1" name="DISPATCH"/>
		<bitfield pos="2" name="UNK2"/>
		<bitfield pos="3" name="UNK3"/>
		<bitfield pos="4" name="UNK4"/>
		<bitfield pos="5" name="UNK5"/>
		<bitfield pos="6" name="M2MF"/>
		<bitfield pos="7" name="UNK7"/>
		<bitfield pos="8" name="CTXPROG"/>
		<bitfield pos="9" name="VFETCH"/>
		<bitfield pos="10" name="CCACHE_PREGEOM"/>
		<bitfield pos="11" name="STRMOUT_VATTR_POSTGEOM"/>
		<bitfield pos="12" name="VCLIP"/>
		<bitfield pos="13" name="RATTR_APLANE"/>
		<bitfield pos="14" name="TRAST"/>
		<bitfield pos="15" name="CLIPID"/>
		<bitfield pos="16" name="ZCULL"/>
		<bitfield pos="17" name="ENG2D"/>
		<bitfield pos="18" name="RMASK"/>
		<bitfield pos="19" name="TPC_RAST"/>
		<bitfield pos="20" name="TPC_PROP"/>
		<bitfield pos="21" name="TPC_TEX"/>
		<bitfield pos="22" name="TPC_GEOM"/>
		<bitfield pos="23" name="TPC_MP"/>
		<bitfield pos="24" name="ROP"/>
	</reg32>
	<reg32 offset="0x0704" name="TRAPPED_ADDR">
		<doc>Offending subchan + method, for [most types of] PGRAPH interrupts.</doc>
		<bitfield name="MTHD" high="12" low="2" shr="2" />
		<bitfield name="SUBCH" high="18" low="16" />
		<bitfield name="UNK28" pos="24" />
		<bitfield name="UNK" pos="31" />
	</reg32>
	<reg32 offset="0x0708" name="TRAPPED_DATA_LOW">
		<doc>Offending method data, for [most types of] PGRAPH interrupts.</doc>
	</reg32>
	<reg32 offset="0x070c" name="TRAPPED_DATA_HIGH" /> <!-- I have no idea what this is for. But it's been around since NV10. -->
	<reg32 offset="0x0748" name="UNK748" />
	<reg32 offset="0x0784" name="CTXCTL_SWAP" type="nv50_channel">
		<doc>Channel whose grctx is read/written by ctxprog opcodes 1XXXXX, 8XXXXX.</doc>
	</reg32>

	<array offset="0x0800" name="DISPATCH" stride="0x400" length="1">
		<reg32 offset="0x004" name="TRAP">
			<bitfield name="FAULT" pos="0" /> <!-- COND/NOTIFIER faults at least. check 800848? -->
			<bitfield name="QUERY" pos="1" /> <!-- hmm... -->
			<bitfield name="GRCTX_FAULT_MMIO" pos="2" />
			<bitfield name="GRCTX_FAULT_XFER1" pos="3" />
			<bitfield name="GRCTX_FAULT_XFER2" pos="4" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x008" name="CMD_ADDR">
			<bitfield name="MTHD" high="12" low="2" shr="2" />
			<bitfield name="SUBCH" high="18" low="16" />
			<bitfield name="NONINCR" pos="20" />
			<bitfield name="UNK1" pos="21" /> <!-- sometimes set by DISPATCH itself during exec... related to NOTIFY? -->
			<bitfield name="SINGLE_STEP_DONE" pos="22" />
			<bitfield name="UNK3" high="24" low="23" />
			<bitfield name="DOUBLE" pos="25" />
			<bitfield name="UNK2" pos="28" />
			<bitfield name="CURRENT_SUBCH" pos="29" />
			<bitfield name="VALID" pos="31" />
		</reg32>
		<reg32 offset="0x00c" name="CMD_DATA_LOW" />
		<reg32 offset="0x010" name="CMD_DATA_HIGH" />
		<reg32 offset="0x014" name="CTX_SWITCH_1">
			<bitfield name="CLASS" high="15" low="0"/>
			<bitfield name="COLOR_KEY" pos="16"/>
			<bitfield name="USER_CLIP" pos="17"/>
			<bitfield name="UNK19" high="31" low="19" />
		</reg32>
		<reg32 offset="0x018" name="CTX_SWITCH_2">
			<bitfield name="NOTIFY_INSTANCE" high="15" low="0"/>
			<bitfield name="UNK24" high="31" low="24" />
		</reg32>
		<reg32 offset="0x01c" name="CTX_SWITCH_3">
			<bitfield name="DMA_INSTANCE" high="15" low="0">
				<doc>Only used for sifm, gdirect, m2mf.</doc>
			</bitfield>
			<bitfield name="ENDIAN" pos="24">
				<value value="0" name="LITTLE" />
				<value value="1" name="BIG" />
			</bitfield>
			<bitfield name="SINGLE_STEP" pos="26" />
		</reg32>
		<reg32 offset="0x020" name="CTX_SWITCH_4">
			<bitfield name="MY_INSTANCE" high="31" low="16"/>
			<bitfield name="COND_INSTANCE" high="15" low="0">
				<doc>Also second DMA slot on m2mf.</doc>
			</bitfield>
		</reg32>
		<reg32 offset="0x024" name="CTXCTL_FLAGS_0">
			<bitfield name="SWAP_DIRECTION" pos="0">
				<value value="0" name="LOAD" />
				<value value="1" name="SAVE" />
			</bitfield>
			<bitfield name="UNK1" pos="1"/> <!-- set while loading/saving context... -->
			<bitfield name="DISPATCH_DROP" pos="3"/> <!-- causes incoming methods to get ignored, haven't dug deeper yet. -->
			<bitfield name="XFER_ENABLE" pos="14"/> <!-- xfer just hangs when attempted without this bit set. -->
			<bitfield name="PM0" pos="28"/>
			<bitfield name="PM1" pos="29"/>
			<bitfield name="PM2" pos="30"/>
			<bitfield name="PM3" pos="31"/>
		</reg32>
		<reg32 offset="0x028" name="CTXCTL_FLAGS_1"> <!-- saved to context -->
			<bitfield name="UNK0" pos="0"/> <!-- weird stuff happens when not set -->
		</reg32>
		<reg32 offset="0x02c" name="CTXCTL_FLAGS_2">
			<bitfield name="IDLE" pos="0" />
			<bitfield name="UNK1" pos="1" /> <!-- usually 1, but seen 0 on NVA5.. -->
			<bitfield name="AUTO_SAVE" pos="4" />
			<bitfield name="AUTO_LOAD" pos="5" />
			<bitfield name="UNK9" pos="9" /> <!-- seems to indicate some sort of ctxprog error. or maybe busy condition. you're in deep shit if this is 1 for you. -->
			<bitfield name="NEWCTX_DONE" pos="10" /> <!-- extraordinarly weird. seems to blink "1" only for a very short amount of time. you need the wait right after the cmd. -->
			<bitfield name="XFER_BUSY" pos="11" />
			<bitfield name="TIMER_ZERO" pos="12" />
			<bitfield name="ALWAYS_TRUE" pos="13" />
			<bitfield name="INTR_PENDING" pos="15" />
		</reg32>
		<reg32 offset="0x030" name="CTXCTL_FLAGS_3">
		</reg32>

		<reg32 offset="0x044" name="UNK044">
			<bitfield name="UNK0" pos="0" />
			<bitfield name="SUBCH" high="15" low="13" />
			<bitfield name="UNK31" pos="31" />
		</reg32>
		<reg32 offset="0x048" name="MISC">
			<bitfield name="NOTIFY_FAULT" pos="0" />
			<bitfield name="COND_FAULT" pos="3" />
			<bitfield name="NOTIFY_PENDING" pos="8" />
			<bitfield name="NOTIFY_AWAKEN" pos="16" />
		</reg32>
		<reg32 offset="0x04c" name="ST2_ADDR">
			<doc>Second stage of dispatch... if QUERY blows up on you,
			it can get stuck here. At least sometimes.</doc>
			<bitfield name="MTHD" high="12" low="2" shr="2" />
			<bitfield name="UNK28" pos="28" />
			<bitfield name="ILLEGAL_CLASS" pos="29" />
			<bitfield name="ILLEGAL_MTHD" pos="30" />
			<bitfield name="VALID" pos="31" />
		</reg32>

		<reg32 offset="0x05c" name="ST2_DATA_LOW" />
		<reg32 offset="0x060" name="ST2_DATA_HIGH" />

		<reg32 offset="0x068" name="ST2_DATA_ERROR">
			<bitfield high="15" low="0" name="TYPE" type="NV50_PGRAPH_DATA_ERROR" />
			<bitfield pos="16" name="VALID" />
		</reg32>
		<reg32 offset="0x06c" name="ST3_ADDR">
			<bitfield name="MTHD" high="12" low="2" shr="2" />
			<bitfield name="UNK28" pos="28" />
			<bitfield name="VALID" pos="31" />
		</reg32>
		<reg32 offset="0x074" name="ST3_DATA_LOW" />
		<reg32 offset="0x078" name="ST3_DATA_HIGH" />
		<reg32 offset="0x07c" name="ST4_DATA_ERROR">
			<bitfield high="15" low="0" name="TYPE" type="NV50_PGRAPH_DATA_ERROR" />
			<bitfield pos="31" name="VALID" />
		</reg32>

		<reg32 offset="0x084" name="ST5_ADDR">
			<bitfield high="17" low="0" name="INDEX" />
			<bitfield high="21" low="20" name="UNK1" />
			<bitfield pos="31" name="VALID" />

		</reg32>
		<reg32 offset="0x088" name="ST5_DATA" />

		<reg32 offset="0x098" name="ST6_DATA" />
		<reg32 offset="0x09c" name="ST6_ADDR" />

		<reg32 offset="0x0dc" name="COND_ADDRESS_HIGH">
			<bitfield name="3D" high="7" low="0" />
			<bitfield name="2D" high="15" low="8" />
		</reg32>
		<reg32 offset="0x0e0" name="COND_ADDRESS_LOW_3D" />
		<reg32 offset="0x0e4" name="COND_ADDRESS_LOW_2D" />
		<reg32 offset="0x0e8" name="COND">
			<bitfield name="3D" pos="0" />
			<bitfield name="2D" pos="1" />
			<bitfield name="UNK6" pos="6" /> <!-- COND traps cause this to be set. being set seems to prevent context switching and generally wreak havoc... -->
		</reg32>

		<reg32 offset="0x0f8" name="CLOCK" />
		<reg32 offset="0x0fc" name="UNITS">
			<bitfield name="TPC_MASK" high="15" low="0" />
			<bitfield name="ROP_MASK" high="21" low="16" variants="NV50:NVA0" />
			<bitfield name="MP_MASK" high="23" low="22" variants="NV50:NVA0" />
			<bitfield name="ROP_MASK" high="23" low="16" variants="NVA0-" />
			<bitfield name="MP_MASK" high="31" low="28" variants="NVA0-" />
		</reg32>
	</array>
	
	<array offset="0x0c00" name="VFETCH" stride="0x400" length="1">
		<reg32 offset="0x00" name="JOE" />
		<reg32 offset="0x04" name="TRAP">
			<bitfield name="FAULT" pos="0" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
	</array>

	<array offset="0x1000" name="VATTR" stride="0x400" length="1">
		<reg32 offset="0x00" name="JOE" />
	</array>

	<array offset="0x1400" name="VCLIP" stride="0x400" length="1">
		<reg32 offset="0x130" name="JOE" />
	</array>

	<array offset="0x1800" name="STRMOUT" stride="0x400" length="1">
		<reg32 offset="0x00" name="TRAP">
			<bitfield name="FAULT" pos="0" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x04" name="TRAPPED_STATUS" /> <!-- probably. -->
		<reg32 offset="0x08" name="TRAPPED_ADDRESS_LOW" />
		<reg32 offset="0x0c" name="TRAPPED_ADDRESS_HIGH" />
		<reg32 offset="0x10" name="TRAPPED_DMA" />
		<reg32 offset="0x18" name="JOE" />
	</array>

	<array offset="0x1c00" name="TRAST" stride="0x400" length="1">
		<reg32 offset="0x04" name="JOE" />
	</array>

	<array offset="0x2000" name="CLIPID" stride="0x400" length="1">
		<reg32 offset="0x00" name="TRAP">
			<bitfield name="FAULT" pos="0" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x0c" name="JOE" variants="NVA0-" />
	</array>

	<array offset="0x2400" name="ATTR" stride="0x400" length="1">
		<reg32 offset="0x04" name="JOE" />
	</array>

	<array offset="0x2800" name="APLANE" stride="0x400" length="1">
		<reg32 offset="0x04" name="JOE" />
	</array>

	<array offset="0x2c00" name="ZCULL" stride="0x400" length="1">
		<reg32 offset="0x18" name="UNK18"/> <!-- mask... -->
		<array offset="0x20" name="REGION" stride="0x10" length="8">
			<reg32 offset="0" name="UNK0" />
			<reg32 offset="4" name="SIZE">
				<bitfield name="HEIGHT" high="15" low="0" type="uint" />
				<bitfield name="WIDTH" high="31" low="16" type="uint" />
				<doc>Both aligned to 64. Takes effect immediately.</doc>
			</reg32>
			<reg32 offset="8" name="BASE" /><!-- in pixels (width * height) -->
			<reg32 offset="0xc" name="UNK3">
				<doc>Blob initializes this to ff806001.
				NV50_3D method 0dbc bit  0 appears in bit 1,
				NV50_3D method 0dbc bit 16 appears in bit 2.
				</doc>
			</reg32>
		</array>
		<reg32 offset="0xbc" name="JOE" />
	</array>

	<array offset="0x3000" name="ENG2D" stride="0x400" length="1">
		<reg32 offset="0x00" name="JOE" />
	</array>

	<array offset="0x3400" name="RMASK" stride="0x400" length="1">
		<reg32 offset="0x00" name="JOE" variants="NVA0-" /> <!-- ? -->
	</array>

	<array offset="0x4c00" name="TPC_CTRL" stride="0x400" length="1">
		<reg32 offset="0x200" name="TPC_VSTATUS" access="r" length="16">
			<bitfield low="0" high="2" name="RAST" type="NV50_VSTATUS"/>
			<bitfield low="3" high="5" name="PROP" type="NV50_VSTATUS"/>
			<bitfield low="6" high="8" name="TEX" type="NV50_VSTATUS"/>
			<bitfield low="9" high="11" name="GEOM" type="NV50_VSTATUS"/> <!-- unconfirmed -->
			<bitfield low="12" high="14" name="MP" type="NV50_VSTATUS"/>
			<bitfield low="15" high="17" name="PREGEOM" type="NV50_VSTATUS"/>
			<bitfield low="18" high="20" name="POSTGEOM" type="NV50_VSTATUS"/>
		</reg32>
		<reg32 offset="0x300" name="VSTATUS" access="r">
			<bitfield low="0" high="2" name="TPC" type="NV50_VSTATUS"/> <!-- unconfirmed -->
			<bitfield low="3" high="5" name="PREGEOM" type="NV50_VSTATUS"/>
			<bitfield low="6" high="8" name="POSTGEOM" type="NV50_VSTATUS"/>
		</reg32>
	</array>

	<array offset="0x5000" name="CCACHE" stride="0x400" length="1">
		<array offset="0x04" name="UNK04" stride="8" length="2">
			<reg32 offset="0" name="UNK0" />
			<reg32 offset="4" name="UNK1" />
		</array>
		<reg32 offset="0x18" name="TRAP">
			<bitfield name="FAULT" pos="0" />
			<bitfield name="UNK1" pos="1" />
			<bitfield name="UNK2" pos="2" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x28" name="JOE" /> <!-- a bit... different. -->
	</array>

	<array offset="0x6800" name="M2MF" stride="0x400" length="1">
		<reg32 offset="0x00" name="TRAP">
			<bitfield name="NOTIFY" pos="0" />
			<bitfield name="IN" pos="1" />
			<bitfield name="OUT" pos="2" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x4c" name="OFFSET_IN_0_HIGH" />
		<reg32 offset="0x50" name="OFFSET_IN_0_LOW" />
		<reg32 offset="0x54" name="OFFSET_IN_1_HIGH" />
		<reg32 offset="0x58" name="OFFSET_IN_1_LOW" />

		<reg32 offset="0x88" name="OFFSET_OUT_0_HIGH" />
		<reg32 offset="0x8c" name="OFFSET_OUT_0_LOW" />
		<reg32 offset="0x90" name="OFFSET_OUT_1_HIGH" />
		<reg32 offset="0x94" name="OFFSET_OUT_1_LOW" />
	</array>

	<reg32 offset="0x6ff0" name="UNK_CHANINST" length="3">
		<doc>Blob ctxprogs sometimes write current channel's
		instance address >> 12 in here, as well as the following
		two registers. No idea what this is for, our progs don't
		do it and seems like nothing bad happens. Note that NV40
		also has such registers... they're 408000, 408004, 408008
		and store GRCTX instance instead.
		</doc>
	</reg32>

	<array offset="0x7000" name="ROP" stride="0x100" length="8">
		<array offset="0" name="CROP" stride="0x80" length="1">
			<reg32 offset="0x0c" name="JOE" />
			<!-- should be set to the same value as PFB.BANKCFG -->
			<reg32 offset="0x10" name="BANKCFG"/>
		</array>
		<array offset="0x80" name="ZROP" stride="0x80" length="1">
			<reg32 offset="0x10" name="JOE" />
			<reg32 offset="0x14" name="BANKCFG"/>
		</array>
	</array>

	<array offset="0x7c00" name="ZBAR" stride="0x100" length="1">

	</array>
	<array offset="0x7d00" name="CBAR" stride="0x100" length="1">
		<reg32 offset="0x00" name="SAMPLECNT"/>
		<reg32 offset="0x20" name="BANKCFG"/>
	</array>

	<group name="nv50_pgraph_mp">
		<reg64 offset="0x00" name="CODE_CONFIG_0">
			<bitfield low="0" high="21" name="FP_START_ID" shr="2"/>
			<bitfield low="22" high="25" name="FP_CALL_LIMIT_LOG"/>
			<bitfield low="26" high="47" name="VP_START_ID" shr="2"/>
			<bitfield low="48" high="51" name="VP_CALL_LIMIT_LOG"/>
		</reg64>
		<reg64 offset="0x08" name="CODE_CONFIG_1">
			<bitfield low="0" high="21" name="GP_START_ID" shr="2"/>
			<bitfield low="22" high="25" name="GP_CALL_LIMIT_LOG"/>
			<bitfield low="26" high="57" name="UNK1568_UNK02B0"/>
		</reg64>
		<reg32 offset="0x10" name="PM_SIG">
			<bitfield low="0" high="7" name="0"/>
			<bitfield low="8" high="15" name="1"/>
			<bitfield low="16" high="23" name="2"/>
			<bitfield low="24" high="31" name="3"/>
		</reg32>
		<reg32 offset="0x14" name="ERROR_CODE">
			<bitfield pos="0" name="STACK_UNDERFLOW"/>
			<bitfield pos="1" name="STACK_MISMATCH"/>
			<bitfield pos="2" name="QUADON_ACTIVE"/>
			<bitfield pos="3" name="TIMEOUT"/>
			<bitfield pos="4" name="INVALID_OPCODE"/>
			<bitfield pos="5" name="PM_OVERFLOW"/>
			<bitfield pos="6" name="BREAKPOINT" variants="NV84-"/>
			<bitfield pos="7" name="UNK7" variants="NVA0-"/>
			<bitfield pos="16" name="UNK16"/>
			<bitfield pos="17" name="UNK17"/>
		</reg32>
		<reg64 offset="0x18" name="UNK18">
			<bitfield low="0" high="7" name="UNK12A8_UNK0228_UNK12"/>
			<bitfield pos="8" name="UNK12A8_UNK0228_UNK0"/>
			<bitfield low="9" high="16" name="UNK12A8_UNK0228_UNK4"/>
			<bitfield pos="17" name="UNK12AC_UNK0290"/>
			<bitfield low="18" high="25" name="PM_SIG_UNIT1_0"/>
			<bitfield low="26" high="33" name="PM_SIG_UNIT1_1"/>
			<bitfield low="34" high="41" name="PM_SIG_UNIT1_2"/>
			<bitfield low="42" high="49" name="PM_SIG_UNIT1_3"/>
			<bitfield low="50" high="57" name="UNK50"/>
			<bitfield pos="60" name="UNK60"/>
			<bitfield pos="61" name="UNK61" variants="NVA0-"/>
		</reg64>
		<reg32 offset="0x20" name="UNK20">
			<bitfield low="0" high="28" name="UNK0"/>
			<bitfield pos="29" name="UNK29" variants="NV84-"/>
			<bitfield low="30" high="31" name="UNK30" variants="NVA0-"/>
		</reg32>
		<reg32 offset="0x24" name="PC_CURRENT">
			<bitfield low="0" high="23" name="ADDR"/>
			<bitfield low="24" high="28" name="WARP"/>
		</reg32>
		<reg64 offset="0x28" name="PM_COUNTER" length="4"/>
		<reg64 offset="0x38" name="PM_FUNC">
			<bitfield low="0" high="15" name="0"/>
			<bitfield low="16" high="31" name="1"/>
			<bitfield low="32" high="47" name="2"/>
			<bitfield low="48" high="63" name="3"/>
		</reg64>
		<reg32 offset="0x40" name="REG_ALLOC">
			<bitfield low="0" high="7" name="GP_TEMP"/>
			<bitfield low="8" high="15" name="FP_TEMP"/>
			<bitfield low="16" high="23" name="VP_TEMP"/>
			<bitfield low="24" high="30" name="UNK24"/>
			<bitfield pos="31" name="UNK31" variants="NVA0-"/>
		</reg32>
		<reg32 offset="0x44" name="PM_SIG_UNIT0">
			<bitfield low="0" high="7" name="0"/>
			<bitfield low="8" high="15" name="1"/>
			<bitfield low="16" high="23" name="2"/>
			<bitfield low="24" high="31" name="3"/>
		</reg32>
		<reg64 offset="0x48" name="UNK48"/>
		<reg64 offset="0x50" name="UNK50"/>
		<reg64 offset="0x58" name="CONTROL">
			<bitfield low="0" high="7" name="FP_INTERPOLANT_COUNT_NONFLAT"/>
			<bitfield low="8" high="15" name="FP_INTERPOLANT_COUNT"/>
			<bitfield low="16" high="20" name="WATCHDOG"/>
			<bitfield pos="21" name="KILL"/> <!-- XXX: also convered by the WATCHDOG ICMD? -->
			<bitfield pos="22" name="PM_OVERFLOW_TRAP_ENABLE_0"/>
			<bitfield pos="23" name="PM_OVERFLOW_TRAP_ENABLE_1"/>
			<bitfield pos="24" name="PM_OVERFLOW_TRAP_ENABLE_2"/>
			<bitfield pos="25" name="PM_OVERFLOW_TRAP_ENABLE_3"/>
			<bitfield low="26" high="28" name="PM_UNIT_0" type="nv50_mp_pm_unit"/>
			<bitfield low="29" high="31" name="PM_UNIT_1" type="nv50_mp_pm_unit"/>
			<bitfield low="32" high="34" name="PM_UNIT_2" type="nv50_mp_pm_unit"/>
			<bitfield low="35" high="37" name="PM_UNIT_3" type="nv50_mp_pm_unit"/>
			<bitfield pos="38" name="FP_INTERPOLANT_UNK28"/>
			<bitfield pos="39" name="FP_INTERPOLANT_UMASK_W"/>
			<bitfield pos="40" name="FP_INTERPOLANT_UMASK_Z"/>
			<bitfield pos="41" name="FP_INTERPOLANT_UMASK_Y"/>
			<bitfield pos="42" name="FP_INTERPOLANT_UMASK_X"/>
			<bitfield pos="43" name="UNK1690_UNK8"/>
			<bitfield pos="44" name="UNK1690_UNK4"/>
			<bitfield pos="45" name="UNK1690_UNK0"/>
			<bitfield pos="46" name="PM_MODE_0" type="nv50_mp_pm_mode"/>
			<bitfield pos="47" name="PM_MODE_1" type="nv50_mp_pm_mode"/>
			<bitfield pos="48" name="PM_MODE_2" type="nv50_mp_pm_mode"/>
			<bitfield pos="49" name="PM_MODE_3" type="nv50_mp_pm_mode"/>
			<bitfield low="50" high="53" name="UNK50"/>
			<bitfield pos="54" name="PM_OVERFLOW_TRAP_0"/>
			<bitfield pos="55" name="PM_OVERFLOW_TRAP_1"/>
			<bitfield pos="56" name="PM_OVERFLOW_TRAP_2"/>
			<bitfield pos="57" name="PM_OVERFLOW_TRAP_3"/>
			<bitfield low="58" high="59" name="UNK58" variants="NV84-"/>
			<bitfield low="60" high="63" name="UNK60" variants="NVA3-"/>
		</reg64>
		<reg64 offset="0x60" name="UNK60">
			<bitfield pos="0" name="UNK1690_UNK037C_ALWAYS_DERIV"/>
			<bitfield pos="1" name="UNK1690_UNK037C_UNK16"/>
			<bitfield low="2" high="5" name="PM_SIG_UNIT2_0"/>
			<bitfield low="6" high="9" name="PM_SIG_UNIT2_1"/>
			<bitfield low="10" high="13" name="PM_SIG_UNIT2_2"/>
			<bitfield low="14" high="17" name="PM_SIG_UNIT2_3"/>
			<bitfield low="18" high="19" name="UNK18" variants="NVA0-"/>
		</reg64>
		<reg64 offset="0x68" name="UNK68" variants="NVA0-"/> <!-- 3f -->
		<reg64 offset="0x70" name="OPCODE"/>
		<reg64 offset="0x78" name="PC_PREVIOUS">
			<bitfield low="0" high="23" name="ADDR"/>
			<bitfield low="24" high="28" name="WARP"/>
		</reg64>
	</group>
	<group name="nv50_pgraph_mpc">
		<doc>MP Context. The whole state of MP is accessible indirectly via these registers.
		There are two main areas: small and large. Large contains $r registers and s[]
		space contents. Small contains everything else.
		</doc>
		<reg32 offset="0xb0" name="MPC_SMALL_SELECT">
			<doc>Selects the 64-bit thing accessible by MPC_SMALL_DATA window.</doc>
			<bitfield high="1" low="0" name="MP">
				<doc>Selects which MP of this TPC to access.</doc>
			</bitfield>
			<bitfield high="5" low="2" name="SPACE">
				<doc>Selects which space to access.</doc>
				<value value="0" name="MP_MAIN">
					<doc>Same thing as available directly via PGRAPH_TPC_MP.
					Wraps on index 16.</doc>
				</value>
				<value value="1" name="MISC1"/>
				<value value="2" name="UNK2"/>
				<value value="3" name="MISC3"/>
				<value value="4" name="UNK4"/>
				<value value="5" name="UNK6" variants="NV50:NVA0"/>
				<value value="6" name="UNK7" variants="NV50:NVA0"/>
				<value value="8" name="UNK9" variants="NV50:NVA0"/> <!-- code cache? -->
				<value value="9" name="UNK10" variants="NV50:NVA0"/>
				<value value="0xa" name="UNK11" variants="NV50:NVA0"/>
				<value value="0xb" name="SFU_LUT" variants="NV50:NVA0"/>
				<value value="5" name="UNK5" variants="NVA0-"/>
				<value value="6" name="UNK6" variants="NVA0-"/>
				<value value="7" name="UNK7" variants="NVA0-"/>
				<value value="9" name="UNK9" variants="NVA0-"/> <!-- code cache? -->
				<value value="0xa" name="UNK10" variants="NVA0-"/>
				<value value="0xb" name="UNK11" variants="NVA0-"/>
				<value value="0xc" name="SFU_LUT" variants="NVA0-"/>
			</bitfield>
			<bitfield high="31" low="6" name="INDEX">
				<doc>Index inside the selected SPACE to access.
				This bitfield is really smaller, and its usable size
				depends on selected SPACE.</doc>
			</bitfield>
		</reg32>
		<reg64 offset="0xb4" name="MPC_SMALL_DATA" length="2"/>
		<reg32 offset="0xbc" name="MPC_LARGE_SELECT">
			<doc>Selects the 16-word thing accessible by MPC_LARGE_DATA window.</doc>
			<bitfield high="1" low="0" name="MP">
				<doc>Selects which MP of this TPC to access.</doc>
			</bitfield>
			<bitfield pos="2" name="SPACE">
				<value value="0" name="REGS">
					<doc>$r registers. These are grouped in 64-reg groups.
					The (warpid, reg index) -> (group, rindex, index)
					mapping can be found in NV50_MPC_SMALL3_LOC0.</doc>
				</value>
				<value value="1" name="SHARED">
					<doc>s[] space, in 64-byte groups.
					(block, offset/64) -> group number mapping can be found
					in NV50_MPC_SMALL3_LOC0.</doc>
				</value>
			</bitfield>
			<bitfield high="4" low="3" name="RINDEX">
				<doc>For registers, selects which subgroup of 16 regs to select
				from the selected 64-reg group. Unused for s[].</doc>
			</bitfield>
			<bitfield high="12" low="5" name="GROUP">
				<doc>Group index to select. Bit 12 is ignored for regs
				on pre-NVA0 cards.</doc>
			</bitfield>
		</reg32>
		<reg32 offset="0xc0" name="MPC_LARGE_DATA" length="16" />
	</group>

	<group name="nv50_pgraph_prop">
		<reg32 offset="0x08" name="TRAP">
			<bitfield name="SURF_WIDTH_OVERRUN" pos="2" />
			<bitfield name="SURF_HEIGHT_OVERRUN" pos="3" />
			<bitfield name="DST2D_FAULT" pos="4" />
			<bitfield name="ZETA_FAULT" pos="5" />
			<bitfield name="RT_FAULT" pos="6" />
			<bitfield name="CUDA_FAULT" pos="7" />
			<bitfield name="DST2D_STORAGE_TYPE_MISMATCH" pos="8" />
			<bitfield name="ZETA_STORAGE_TYPE_MISMATCH" pos="9" />
			<bitfield name="RT_STORAGE_TYPE_MISMATCH" pos="10" />
			<bitfield name="DST2D_LINEAR_MISMATCH" pos="11" />
			<bitfield name="RT_LINEAR_MISMATCH" pos="12" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x28" name="JOE" />
	</group>

	<group name="nv50_pgraph_tpc_rast">
		<reg32 offset="0x04" name="JOE" />
	</group>

	<group name="nv50_pgraph_tpc_geom">
		<reg32 offset="0x14" name="JOE" />
	</group>

	<bitset name="nv50_mpc_trap" inline="yes">
		<bitfield name="LOCAL_LIMIT_READ" pos="0"/>
		<bitfield name="LOCAL_LIMIT_WRITE" pos="4"/>
		<bitfield name="STACK_LIMIT" pos="6"/>
		<bitfield name="GLOBAL_LIMIT_READ" pos="8"/>
		<bitfield name="GLOBAL_LIMIT_WRITE" pos="12"/>
		<bitfield name="MP0" pos="16"/>
		<bitfield name="MP1" pos="17"/>
		<bitfield name="GLOBAL_LIMIT_RED" pos="18" variants="NV84-"/>
		<bitfield name="GLOBAL_LIMIT_ATOM" pos="22" variants="NV84-"/>
		<bitfield name="MP2" pos="26" variants="NVA0-"/>
	</bitset>
	<array offset="0x8000" variants="NV50:NVA0" name="TPC" stride="0x1000" length="8">
		<array offset="0x200" name="MP" stride="0x80" length="2">
			<use-group name="nv50_pgraph_mp" />
		</array>
		<array offset="0x300" name="MPC" stride="0x100" length="1">
			<reg32 offset="0x10" name="JOE" />
			<reg32 offset="0x14" name="TRAP">
				<bitfield low="0" high="30" name="TRAP" type="nv50_mpc_trap"/>
				<bitfield name="CLEAR" pos="30"/>
				<bitfield name="ENABLE" pos="31"/>
			</reg32>
			<reg32 offset="0x18" name="TRAP_EN" type="nv50_mpc_trap"/>
			<enum name="nv50_pgraph_mpc_pm_group" inline="yes">
				<value value="0x00" name="MP0_FUNC"/>
				<value value="0x01" name="MP1_FUNC"/>
			</enum>
			<reg32 offset="0x30" name="PM_GROUP_SEL">
				<bitfield low="0" high="7" name="0" type="nv50_pgraph_mpc_pm_group"/>
				<bitfield low="8" high="15" name="1" type="nv50_pgraph_mpc_pm_group"/>
				<bitfield low="16" high="23" name="2" type="nv50_pgraph_mpc_pm_group"/>
				<bitfield low="24" high="31" name="3" type="nv50_pgraph_mpc_pm_group"/>
			</reg32>
			<reg32 offset="0x3c" name="PM_OUT_ENABLE" type="boolean"/>
			<use-group name="nv50_pgraph_mpc" />
		</array>
		<array offset="0x400" name="GEOM" stride="0x400" length="1">
			<use-group name="nv50_pgraph_tpc_geom" />
		</array>
		<array offset="0x800" name="TEX" stride="0x400" length="1">
			<reg32 offset="0x024" name="JOE1" />
			<reg32 offset="0x02c" name="JOE2" length="8" />
			<reg32 offset="0x100" name="TRAP">
				<bitfield name="ANY" pos="0" />
				<bitfield name="FAULT" pos="1" />
				<bitfield name="STORAGE_TYPE_MISMATCH" pos="2" />
				<bitfield name="LINEAR_MISMATCH" pos="3" />
				<bitfield name="WRONG_MEMTYPE" pos="5" />
				<bitfield name="CLEAR" pos="30" />
				<bitfield name="ENABLE" pos="31" />
			</reg32>
			<reg32 offset="0x114" name="VSTATUS" length="2" access="r">
				<bitfield low="0" high="2" name="UNK0" type="NV50_VSTATUS"/>
				<bitfield low="4" high="6" name="UNK1" type="NV50_VSTATUS"/>
				<bitfield low="8" high="10" name="UNK2" type="NV50_VSTATUS"/>
				<bitfield low="11" high="13" name="UNK3" type="NV50_VSTATUS"/>
				<bitfield low="14" high="16" name="UNK4" type="NV50_VSTATUS"/>
				<bitfield low="17" high="19" name="UNK5" type="NV50_VSTATUS"/>
				<bitfield low="20" high="22" name="UNK6" type="NV50_VSTATUS"/>
				<bitfield low="23" high="25" name="UNK7" type="NV50_VSTATUS"/>
				<bitfield low="26" high="28" name="UNK8" type="NV50_VSTATUS"/>
				<bitfield low="29" high="31" name="UNK9" type="NV50_VSTATUS"/>
			</reg32>
		</array>
		<array offset="0xc00" name="RAST" stride="0x200" length="1">
			<use-group name="nv50_pgraph_tpc_rast" />
		</array>
		<array offset="0xe00" name="PROP" stride="0x200" length="1">
			<use-group name="nv50_pgraph_prop" />
		</array>
	</array>

	<array offset="0x8000" variants="NVA0-" name="TPC" stride="0x800" length="16">
		<array offset="0x080" name="RAST" stride="0x80" length="1">
			<use-group name="nv50_pgraph_tpc_rast" />
		</array>
		<array offset="0x100" name="MP" stride="0x80" length="4">
			<use-group name="nv50_pgraph_mp" />
		</array>
		<array offset="0x300" name="MPC" stride="0x100" length="1">
			<reg32 offset="0x1c" name="TRAP">
				<bitfield low="0" high="30" name="TRAP" type="nv50_mpc_trap"/>
				<bitfield name="CLEAR" pos="30"/>
				<bitfield name="ENABLE" pos="31"/>
			</reg32>
			<reg32 offset="0x20" name="TRAP_EN" type="nv50_mpc_trap"/>
			<enum name="nva0_pgraph_mpc_pm_group" inline="yes">
				<value value="0x14" name="MP0_FUNC"/>
				<value value="0x28" name="MP1_FUNC"/>
				<value value="0x3c" name="MP2_FUNC"/>
			</enum>
			<reg32 offset="0x3c" name="PM_GROUP_SEL">
				<bitfield low="0" high="7" name="0" type="nva0_pgraph_mpc_pm_group"/>
				<bitfield low="8" high="15" name="1" type="nva0_pgraph_mpc_pm_group"/>
				<bitfield low="16" high="23" name="2" type="nva0_pgraph_mpc_pm_group"/>
				<bitfield low="24" high="31" name="3" type="nva0_pgraph_mpc_pm_group"/>
			</reg32>
			<reg32 offset="0x40" name="PM_OUT_ENABLE" type="boolean"/>
			<reg32 offset="0x58" name="CODE_ADDRESS_HIGH">
				<bitfield low="0" high="7" name="VP"/>
				<bitfield low="8" high="15" name="GP"/>
				<bitfield low="16" high="23" name="FP"/>
			</reg32>
			<reg32 offset="0x5c" name="VP_ADDRESS_LOW"/>
			<reg32 offset="0x60" name="GP_ADDRESS_LOW"/>
			<reg32 offset="0x64" name="FP_ADDRESS_LOW"/>
			<use-group name="nv50_pgraph_mpc" />
		</array>
		<array offset="0x400" name="GEOM" stride="0x100" length="1">
			<use-group name="nv50_pgraph_tpc_geom" />
		</array>
		<array offset="0x500" name="TEX" stride="0x200" length="1">
			<reg32 offset="0x024" name="JOE1" />
			<reg32 offset="0x02c" name="JOE2" length="8" />
			<reg32 offset="0x100" name="TRAP">
				<bitfield name="ANY" pos="0" />
				<bitfield name="FAULT" pos="1" />
				<bitfield name="STORAGE_TYPE_MISMATCH" pos="2" />
				<bitfield name="LINEAR_MISMATCH" pos="3" />
				<bitfield name="WRONG_MEMTYPE" pos="5" />
				<bitfield name="CLEAR" pos="30" />
				<bitfield name="ENABLE" pos="31" />
			</reg32>
			<reg32 offset="0x114" name="VSTATUS" length="2" access="r">
				<bitfield low="0" high="2" name="UNK0" type="NV50_VSTATUS"/>
				<bitfield low="4" high="6" name="UNK1" type="NV50_VSTATUS"/>
				<bitfield low="8" high="10" name="UNK2" type="NV50_VSTATUS"/>
				<bitfield low="11" high="13" name="UNK3" type="NV50_VSTATUS"/>
				<bitfield low="14" high="16" name="UNK4" type="NV50_VSTATUS"/>
				<bitfield low="17" high="19" name="UNK5" type="NV50_VSTATUS"/>
				<bitfield low="20" high="22" name="UNK6" type="NV50_VSTATUS"/>
				<bitfield low="23" high="25" name="UNK7" type="NV50_VSTATUS"/>
				<bitfield low="26" high="28" name="UNK8" type="NV50_VSTATUS"/>
				<bitfield low="29" high="31" name="UNK9" type="NV50_VSTATUS"/>
			</reg32>
		</array>
		<array offset="0x700" name="PROP" stride="0x100" length="1">
			<use-group name="nv50_pgraph_prop" />
		</array>
	</array>
</array>
</domain>

<!-- the MP context spaces. -->
<domain name="NV50_MPC_SMALL1" width="64" varset="chipset"> <!-- 12-bit addressing -->
	<array offset="0" name="STACK" stride="0x10" length="32">
		<reg64 offset="0" name="ENTRY" length="16">
			<bitfield high="21" low="0" name="PC" shr="2" />
			<!-- 22 and 23 are useless -->
			<bitfield high="28" low="24" name="WARPID" />
			<bitfield high="31" low="29" name="TYPE">
				<value value="1" name="BRANCH" />
				<value value="2" name="CALL1" />
				<value value="3" name="CALL2" />
				<value value="4" name="BREAK" />
				<value value="5" name="QUADON" />
				<value value="6" name="JOINAT" />
			</bitfield>
			<bitfield high="63" low="32" name="LANEMASK"/>
		</reg64>
	</array>
	<reg64 offset="0x200" name="MASK0" length="32">
		<doc>State of each lane. The following combinations are possible:
		<ul>
		<li>M1=0, M2=0: active thread, or merely branched off.</li>
		<li>M1=1, M2=0: thread breaked.</li>
		<li>M1=0, M2=1: thread returned.</li>
		<li>M1=1, M2=1: thread exitted.</li>
		</ul>
		</doc>
		<bitfield high="31" low="0" name="M1" />
		<bitfield high="63" low="32" name="M2" />
	</reg64>
	<reg64 offset="0x220" name="STACK_CONTROL" length="32">
		<bitfield high="12" low="0" name="PTR">
			<doc>Index of current top of the stack entry [ie. last pushed
			entry]. 0x1fff if stack empty.</doc>
		</bitfield>
		<bitfield high="31" low="21" name="UNK"/> <!-- some sort of valid masks... -->
	</reg64>
	<reg64 offset="0x240" name="MASK1" length="32">
		<bitfield high="31" low="0" name="ACTIVE">
			<doc>Mask of active lanes in a warp.</doc>
		</bitfield>
		<bitfield high="63" low="32" name="DEAD">
			<doc>Mask of dead lanes, ie. ones that will
			be skipped by texture insns with "live" flag
			set. For CP, VP, GP set to 1 for unused lanes
			in a warp. For FP, set to 1 for unused lanes
			as well as non-visible pixels that are part
			of visible quad and will be used for computing
			derivatives.</doc>
		</bitfield>
	</reg64>
	<reg64 offset="0x260" name="MASK2" length="32">
		<bitfield low="0" high="31" name="UNK0" variants="NV50:NV84"/>
		<bitfield high="63" low="32" name="DEAD" variants="NV84-">
			<doc>Aliases the previous one. nothing to see here.</doc>
		</bitfield>
	</reg64>
	<reg64 offset="0x280" name="PC" shr="2" length="32" variants="NV50:NV84">
		<doc>The per-warp program counters.</doc>
	</reg64>
	<reg64 offset="0x2a0" name="WARPS" variants="NV50:NV84">
		<bitfield high="31" low="0" name="ACTIVE">
			<doc>Mask of currently active warps</doc>
		</bitfield>
		<bitfield high="63" low="32" name="SKIPPED">
			<doc>Mask of warps which will be skipped by the CONT command.
			Note that hitting any sort of breakpoint by a warp causes
			the corresponding bit to get set.
			</doc>
		</bitfield>
	</reg64>
	<reg64 offset="0x2a1" name="MISC2" variants="NV50:NV84">
		<bitfield pos="0" name="UNK0"/>
		<bitfield pos="1" name="UNK1"/>
		<bitfield pos="2" name="SINGLE_STEP">
			<doc>Enables single stepping.</doc>
		</bitfield>
		<bitfield pos="3" name="CONT_TRIGGER">
			<doc>Continues paused execution.</doc>
		</bitfield>
		<bitfield pos="4" name="BREAK"> <!-- XXX: not in scan? -->
			<doc>Will cause next CUDA execution to start in paused state.</doc>
		</bitfield>
		<bitfield high="63" low="32" name="CRASH_MASK">
			<doc>Mask of warps which blew up</doc>
		</bitfield>
	</reg64>
	<!-- something happens at 0x300+... -->
</domain>
<domain name="NV50_MPC_SMALL2" width="64" varset="chipset"> <!-- 12-bit addr -->
	<array offset="0" name="UNK0" stride="2" length="32">
		<reg64 offset="0" name="SLOT" length="2" />
	</array>
	<array offset="0x40" name="BARRIER_WARP" stride="2" length="32">
		<reg64 offset="0" name="SLOT" length="2">
			<bitfield pos="2" name="UNKALWAYSSET1" />
			<bitfield high="11" low="6" name="UNK2" />
			<bitfield high="29" low="26" name="BARID" />
			<bitfield pos="30" name="INCR" />
			<bitfield pos="31" name="WAIT" />
			<bitfield high="45" low="32" name="UNK46" />
			<bitfield pos="53" name="UNKALWAYSSET2" />
			<bitfield pos="61" name="UNK8" />
		</reg64>
	</array>
	<reg64 offset="0x80" name="UNK2" length="32" />
	<reg64 offset="0xa0" name="UNK3" length="32" />
	<array offset="0xc0" name="UNK4" stride="2" length="32"> <!-- made of 40-bit quantities -->
		<reg64 offset="0" name="UNK0" />
		<reg64 offset="1" name="UNK1" />
	</array>
	<reg64 offset="0x100" name="BARRIER_COUNTER" length="16" variants="NV50:NV84">
		<doc>The counters associated with barriers. Inexplicably shifted left by 1 bit. 6-bit on pre-NVA0, most likely 7-bit on NVAx.</doc>
	</reg64>
	<reg64 offset="0x110" name="UNK6" length="8" variants="NV50:NV84"/> <!-- bits f -->
</domain>
<domain name="NV50_MPC_SMALL3" width="64" varset="chipset"> <!-- 12-bit addr -->
	<reg64 offset="0" name="ADDRESS" length="0x400">
		<doc>$a1-$a4 registers... this shit is so ugly,
		I won't even bother expressing it with proper
		arrays. Basically, register $ax of warp y
		lane z is at bits 16*(z&amp;3)...16*(z&amp;3)+15
		of qword index
		((z&amp;0x10)&gt;&gt;4) + (x-1)*2 + y*8 + ((z&amp;0xc)&gt;&gt;2) * 0x100
		</doc>
	</reg64>
	<reg64 offset="0x400" name="COND" length="0x100">
		<doc>$c0-$c3 registers. Reg $cx of warp y
		lane z is at bits 4*(z&amp;0xf)...4*(z&amp;0xf)+3
		of qword index 
		</doc>
	</reg64>
	<reg64 offset="0x500" name="LOC0" length="0x20">
		<doc>General information about a given warp.</doc>
		<bitfield pos="0" name="REG_PACKED">
			<doc>Use the "packed" format for $r storage.
			If this bit is 0, the "striped" format for $r storage is used.
			Register $rx for thread y in this warp can be find in group
			REG_START + x, at rindex REG_RINDEX + ((y&amp;0x10)>>4),
			in word (y&amp;0xf). Otherwise, the "packed" format for $r
			storage is used, and reg $rx of thread y is stored in group
			REG_GROUP_START + (x>>2) at rindex ((x&amp;3)^(warpid&amp;3)).
			Also, the warps are limitted to 16 threads in this case.</doc>
		</bitfield>
		<bitfield high="3" low="1" name="UNK1" /> <!-- 000 for VP, 001 for GP, 100 for FP, 110 for CP? hm. -->
		<bitfield high="5" low="4" name="REG_RINDEX">
			<doc>The RINDEX to be used for $r regs in this warp, if format is not PACKED.</doc>
		</bitfield>
		<bitfield high="13" low="6" name="REG_START">
			<doc>The starting group number of $r regs in this warp.</doc>
		</bitfield>
		<bitfield high="20" low="14" name="REG_NUM">
			<doc>Number of $r regs in this warp.</doc>
		</bitfield>
		<bitfield high="28" low="21" name="SHARED_START">
			<doc>For CPs, the starting group number of s[] memory of this warp.</doc>
		</bitfield>
		<bitfield high="36" low="29" name="SHARED_LIMIT">
			<doc>For CPs, number of s[] groups - 1.</doc>
		</bitfield>
		<bitfield high="52" low="45" name="BARRIER_START">
		</bitfield>

	</reg64>
	<reg64 offset="0x520" name="LOC1" length="0x20">
		<doc>More general information about a given warp.</doc>
		<!-- 00000000XXXXa0a0 for FPs, 0 for VPs, ??? for CPs, ??? for GPs? hm. -->
	</reg64>
	<reg64 offset="0x540" name="A7" length="0x20">
		<bitfield low="0" high="31" name="UNK0"/>
		<doc>$a7 register. Yes, it's per-warp. And it's CP-only.
		Don't ask me why. At least no insane reordering
		is involved.</doc>
		<bitfield low="32" high="47" name="A7"/>
		<bitfield low="48" high="63" name="UNK48" variants="NVA0-"/>
	</reg64>
	<reg64 offset="0x600" name="UNK600" length="0x100"/> <!-- 16-bit really... -->
	<reg64 offset="0x700" name="UNK700" length="0x40" variants="NVA0-"/> <!-- 16-bit -->
</domain>
<domain name="NV50_MPC_SMALL4" width="64"> <!-- 8-bit addr -->
	<reg64 offset="0x00" name="UNK00" length="0x100"/> <!-- 8 per warp actually -->
</domain>
<domain name="NV50_MPC_SMALL5" width="64"> <!-- 8-bit addr; new on NVA0 -->
	<reg64 offset="0x00" name="UNK00" length="0x100"/>
</domain>
<domain name="NV50_MPC_SMALL6" width="64"> <!-- 7-bit addr -->
	<reg64 offset="0x00" name="UNK00" length="0x80"/> <!-- 4 per warp actually -->
</domain>
<domain name="NV50_MPC_SMALL7" width="64"> <!-- 10-bit addr -->
	<reg64 offset="0x000" name="UNK000" length="0x300"/>
</domain>
<domain name="NV50_MPC_SMALL8" width="64"> <!-- 9-bit addr -->
	<reg64 offset="0x000" name="UNK000" length="0x180"/>
</domain>
<domain name="NV50_MPC_SMALL10" width="64"> <!-- 12-bit addr -->
	<reg64 offset="0x000" name="UNK000" length="0x200"/>
</domain>
<domain name="NV50_MPC_SMALL11" width="64"> <!-- ???-bit addr -->
	<reg64 offset="0x000" name="UNK000" length="0x80"/> <!-- 32-bit -->
</domain>
<domain name="NV50_MPC_SFU_LUT" width="64"> <!-- 10-bit addr -->
	<!-- all of the following are in .26 fixed format, for some reason duplicated to make a 52-bit value -->
	<!-- 1/x for x in [1, 2) -->
	<reg64 offset="0x000" name="RCP_LUT_ZERO" length="0x80"/>
	<!-- 1/sqrt(x) for x in [1, 2) -->
	<reg64 offset="0x080" name="RSQRT_1_LUT_ZERO" length="0x40"/>
	<!-- 1/sqrt(x) for x in [2, 4) -->
	<reg64 offset="0x0c0" name="RSQRT_2_LUT_ZERO" length="0x40"/>
	<!-- sin(x) for x in [0, pi/2) -->
	<reg64 offset="0x100" name="SIN_LUT_ZERO" length="0x40"/>
	<!-- 2^x/2 for x in [0, 1) -->
	<reg64 offset="0x140" name="EX2_LUT_ZERO" length="0x40"/>
	<!-- lg2(x) for x in [1, 2) -->
	<reg64 offset="0x180" name="LG2_LUT_ZERO" length="0x40"/>
	<!-- 1 - 1/x^2 for x in [1, 2) -->
	<reg64 offset="0x200" name="RCP_LUT_ONE" length="0x80"/>
	<!-- 1 - 1/sqrt((x^3)) for x in [1, 2) -->
	<reg64 offset="0x280" name="RSQRT_1_LUT_ONE" length="0x40"/>
	<!-- 1 - 4/sqrt((x^3)) for x in [2, 4) -->
	<reg64 offset="0x2c0" name="RSQRT_2_LUT_ONE" length="0x40"/>
	<!-- pi/2*cos(x)/2 for x in [0, pi/2)-->
	<reg64 offset="0x300" name="SINS_LUT_ONE" length="0x40"/>
	<!-- ln(2)*2^x/2 for x in [0, 1) -->
	<reg64 offset="0x340" name="EX2_LUT_ONE" length="0x40"/>
	<!-- lg2(e)/x/2 for x in [1, 2) -->
	<reg64 offset="0x380" name="LG2_LUT_ONE" length="0x40"/>
</domain>

</database>

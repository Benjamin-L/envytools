.. _nv1-pgraph:

===========================
NV1 PGRAPH: graphics engine
===========================

.. contents::


Intruduction
============

.. todo:: write me


MMIO registers
==============

.. space:: 8 nv1-pgraph 0x1000 accelerated drawing engine

   .. todo:: write me


.. _nv1-pgraph-intr:

Interrupts
==========

The PGRAPH registers dealing with interrupts are:

MMIO 0x400100: INTR
  Status of interrupts generated by PGRAPH. On read, returns 1 for bits
  corresponding to pending interrupts. On write, if 1 is written to a bit,
  its interrupt gets cleared, if 0 is written nothing happens.

  - bit 0: INVALID - something was wrong with the submitted method. Detailed
    status is available in the INVALID register. Clearing this bit will also
    clear the INVALID register. In turn, clearing the INVALID register will
    clear this bit.
  - bit 4: CONTEXT_SWITCH - a CTX_SWITCH method was submitted and the channel
    id and/or SUBCONTEXT_ID is different from the current one.
  - bit 8: VBLANK - the vertical blanking period has started on PFB. This
    is really PFB's interrupt. It is delivered to a different PMC line than
    other PGRAPH interrupts. See display/nv1/pfb.txt for details.
  - bit 12: XY_RANGE - an X or Y coordinate used for rendering was out of the
    -0x8000..0x7fff range supported by the rasterizer
  - bit 16: MISSING_METHOD - the final method to do an operation was submitted
    without first submitting other required methods
  - bit 20: CANVAS_SOFTWARE - a drawing operation was attempted with SOFTWARE
    bit set in CANVAS_CONFIG.
  - bit 24: CLIP_SOFTWARE - a drawing operation was attempted with SOFTWARE bit
    set in CLIPRECT_CTRL.
  - bit 28: NOTIFY - a method on which notify interrupt was requested has been
    executed

MMIO 0x400140: INTR_EN
  Interrupt enable bitmask. Set to enable, clear to disable. Interrupts that
  are masked will still show up in INTR when they're triggered, but won't
  cause the PGRAPH or PFB interrupt line to go active. Has same bitfields
  as INTR.

Interrupts other than VBLANK are delivered to PMC interrupt line 12. VBLANK
interrupt is delivered to PMC interrupt line 24.

The INVALID interrupt is further controlled by these registers:

MMIO 0x400104: INVALID
  Status of INVALID subinterrupts. Works like INTR. Clearing this register
  will also clear the INVALID bit in INTR register. In turn, clearing INVALID
  bit in INTR will also clear this register.

  - bit 0: INVALID_METHOD - the method that was submitted does not exist
  - bit 4: INVALID_VALUE - the method was submitted with invalid parameter
  - bit 8: INVALID_NOTIFY - a NOTIFY method was submitted, but NOTIFY_VALID
    was not set in graph object options
  - bit 12: DOUBLE_NOTIFY - a NOTIFY method was submitted with NOTIFY_PENDING
    already set
  - bit 16: CTXSW_NOTIFY - a CTX_SWITCH method was submitted with NOTIFY_PENDING
    set

MMIO 0x400140: INVALID_EN
  INVALID interrupt enable bitmask. Set to enable, clear to disable. Same
  bitfields as INVALID. If any interrupt active in INVALID is also enabled
  here, interrupt line to PMC will be active. Note that this register does
  *not* affect triggering the INVALID bit in INTR and the interrupt status
  from INTR&INTR_EN will be effectively ORed with INVALID&INVALID_EN. Thus
  the contents of INVALID_EN will only matter when INTR_EN.INVALID is set
  to 0.

The INTR and INVALID registers are special and can be written by host even
if ACCESS.HOST is not set.

Note that interrupts that are disabled will still cause PGRAPH to halt and
disable FIFO/HOST bits in ACCESS.


Control and status registers
============================

All access to PGRAPH is controlled by the ACCESS register:

MMIO 0x4006a4: ACCESS
  - bit 0: FIFO - if set to 1, PFIFO is able to write to PGRAPH's MMIO
    registers, ie. can submit methods. If set to 0, PFIFO method
    submission to PGRAPH will be blocked until it's set back to 1.
  - bit 4: DMA - if set to 1, PDMA is able to write to PGRAPH's MMIO registers,
    ie. can respond to DMA read requests. If set to 0, PDMA read data
    will be blocked until it's set back to 1. [XXX: verify]
  - bit 8: HOST - if set to 1, the host is able to write to PGRAPH's MMIO
    registers. If set to 0, writes to all registers in PGRAPH MMIO range
    from host will be ignored, except writes to ACCESS, INTR and INVALID
    registers. Reads to registers other than VTX_POS_* and VTX_BETA_*
    are unaffected.
  - bits 12-16: OBJECT - the type of the current object. Automatically updated
    by PGRAPH when processing method 0. [XXX: what's this for?]
  - bit 24: FIFO_WR - when writing ACCESS and this bit is set to 1 in the
    written value, the FIFO field will be set as per the written value;
    when this bit is set to 0 in the written value, the FIFO field will
    be unaffected. When reading ACCESS, always reads as 1. This, together
    with the following 3 bits, can be used to selectively write ACCESS
    bitfields.
  - bit 25: DMA_WR - like FIFO_WR, but for DMA field
  - bit 26: HOST_WR - like FIFO_WR, but for HOST field
  - bit 27: OBJECT_WR - like FIFO_WR, but for OBJECT field

Note that the FIFO and HOST bits will be automatically cleared by PGRAPH when
an interrupt is triggered by execution of a method. The host has to reenable
HOST access in the interrupt handler to manipulate any PGRAPH state.

The current busy status of PGRAPH can be checked by reading the STATUS
register:

MMIO 0x4006b0: STATUS
  - bit 0: BUSY - PGRAPH is busy processing some method
  - bit 4: XY_LOGIC - PGRAPH is busy calculating vertex coordinates
  - bit 16: DMA - PGRAPH is busy talking to PDMA about IFM or ITM DMA
  - bit 20: DMA_NOTIFY - PGRAPH is busy talking to PDMA about NOTIFY DMA

.. todo:: more bits


Graph object options
====================

On NV1, graph objects come with a 16-bit options field. The field is stored
in the RAMHT structure, and is thus automatically passed to PGRAPH via
method 0 by PFIFO when the active object changes for any reason. The bits in
the options field are:

- bits 0-4: OP - 2d operation [see graph/2d.txt]

  - 0x00: RPOP_DS
  - 0x01: ROP_SDD
  - 0x02: ROP_DSD
  - 0x03: ROP_SSD
  - 0x04: ROP_DDS
  - 0x05: ROP_SDS
  - 0x06: ROP_DSS
  - 0x07: ROP_SSS
  - 0x08: ROP_SSS_ALT
  - 0x09: ROP_PSS
  - 0x0a: ROP_SPS
  - 0x0b: ROP_PPS
  - 0x0c: ROP_SSP
  - 0x0d: ROP_PSP
  - 0x0e: ROP_SPP
  - 0x0f: RPOP_SP
  - 0x10: ROP_DSP
  - 0x11: ROP_SDP
  - 0x12: ROP_DPS
  - 0x13: ROP_PDS
  - 0x14: ROP_SPD
  - 0x15: ROP_PSD
  - 0x17: SRCCOPY
  - 0x18: BLEND_DS_AA
  - 0x19: BLEND_DS_AB
  - 0x1a: BLEND_DS_AIB
  - 0x1b: BLEND_PS_B
  - 0x1c: BLEND_PS_IB

- bit 5: CHROMA - 2d chroma key enable [see graph/2d.txt]
- bit 6: PLANE - 2d plane mask enable [see graph/2d.txt]
- bit 7: CLIP - 2d user clip rectangle enable [see graph/2d.txt]
- bit 8: NOTIFY_VALID - enables the NOTIFY method [see graph/intro.txt]
- bits 9-12: COLOR_FORMAT_DST - a field that selects the 2d color format
  [see graph/2d.txt] and the destination buffer mask [see graph/2d.txt]

  -  0: BUF0_X1R5G5B5_A1R5G5B5
  -  1: BUF0_X8R8G8B8_A8R8G8B8
  -  2: BUF0_X2R10G10B10_A2R10G10B10
  -  3: BUF0_Y8_A8Y8
  -  4: BUF0_Y16_A16Y16
  -  5: BUF1_X1R5G5B5_A1R5G5B5
  -  6: BUF1_X8R8G8B8_A8R8G8B8
  -  7: BUF1_X2R10G10B10_A2R10G10B10
  -  8: BUF1_Y8_A8Y8
  -  9: BUF1_Y16_A16Y16
  - 10: BUF01_X1R5G5B5_A1R5G5B5
  - 11: BUF01_X8R8G8B8_A8R8G8B8
  - 12: BUF01_X2R10G10B10_A2R10G10B10
  - 13: BUF01_Y8_A8Y8
  - 14: BUF01_Y16_A16Y16

- bit 13: ALPHA - 2d alpha enable [see graph/2d.txt]
- bit 14: MONO_FORMAT - 2d mono format [see graph/2d.txt]
- bit 15: SUBCONTEXT_ID - used to implement multiple subcontexts per channel
          [see graph/intro.txt]


Method submission
=================

.. space:: 8 nv1-ubeta 0x2000 BETA object

   .. todo:: write me

.. space:: 8 nv1-urop 0x2000 ROP object

   .. todo:: write me

.. space:: 8 nv1-uchroma 0x2000 CHROMA object

   .. todo:: write me

.. space:: 8 nv1-uplane 0x2000 PLANE object

   .. todo:: write me

.. space:: 8 nv1-uclip 0x2000 CLIP object

   .. todo:: write me

.. space:: 8 nv1-upattern 0x2000 PATTERN object

   .. todo:: write me

.. space:: 8 nv1-upoint 0x2000 POINT object

   .. todo:: write me

.. space:: 8 nv1-uline 0x2000 LINE object

   .. todo:: write me

.. space:: 8 nv1-ulin 0x2000 LIN object

   .. todo:: write me

.. space:: 8 nv1-utri 0x2000 TRI object

   .. todo:: write me

.. space:: 8 nv1-urect 0x2000 RECT object

   .. todo:: write me

.. space:: 8 nv1-ublit 0x2000 BLIT object

   .. todo:: write me

.. space:: 8 nv1-uifc 0x2000 IFC object

   .. todo:: write me

.. space:: 8 nv1-ubitmap 0x2000 BITMAP object

   .. todo:: write me

.. space:: 8 nv1-uifm 0x2000 IFM object

   .. todo:: write me

.. space:: 8 nv1-uitm 0x2000 ITM object

   .. todo:: write me

.. space:: 8 nv1-utexlin 0x2000 TEXLIN object

   .. todo:: write me

.. space:: 8 nv1-utexquad 0x2000 TEXUAD object

   .. todo:: write me

.. space:: 8 nv1-utexlinbeta 0x2000 TEXLINBETA object

   .. todo:: write me

.. space:: 8 nv1-utexquadbeta 0x2000 TEXQUADBETA object

   .. todo:: write me

.. todo:: write me


Context
=======

.. todo:: write me


Surface setup
=============

.. todo:: write me


Drawing operation
=================

.. todo:: write me
